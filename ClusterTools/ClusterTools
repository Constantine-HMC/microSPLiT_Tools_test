#!/root/python/python-3.7.13/python-3.7.13/bin/python3.7
"""ClusterTools"""

"""
authors:
Zhuochong Liu

version:
test.0.0.1

description:
    Temporary None
    Thanks for using ClusterTools and wish you all the best.
"""

import sys
import os
sys.path.append(sys.path[0])
import PCA

function_list = ['PCA', 'Information']
"""Aruguments"""
### Aruguments information of PCA
PCA_arg = {'inputtype':['require','str'], 'inputfile':['require','str'], 'reference':['require','str'], 'config':['require','str'],
           'prefix':['require','str'], 'samindex':['optional','str'], 'outdir':['require','str'], 'threads':['optional','str'],
           'cleanDir':['optional','bool'], 'fastp':['optional','bool'], 'fastqc':['optional','bool'], 'sort':['optional','bool'],
           'markdup':['optional','bool']}

"""Hlep"""
### Help information of MicroGenomeTools
ClusterTools_help = 'Create shell script with preset pipeline and softwares for single sample or multi samples \n' \
                        'Usage: MicroGenomeTools [FUNCTION_MODULE] [OPTIONS]\n' \
                        'Single sample tools:\n' \
                        '    VariantCalling     use GATK to perform variantcalling for WGS data\n' \
                        '    FeatureCounts      use STAR and featureCounts to count reads mapped to transcript for WTS data\n' \
                        'Multi sample tools:\n' \
                        'Information options:\n' \
                        '    Information        show the information of version and authors'


function_help = {'ClusterTools':ClusterTools_help,'PCA': PCA_help}

# Information
Information = 'Version: test.0.0.1\n' \
              'Authors: Zhuochong Liu'

# Customized error type
class ArgumentConflictError(Exception):
    pass

def main(args):
    if len(args) == 0:
        print(function_help['ClusterTools'])
        sys.exit()
    elif len(args) == 1:
        if args[0] in function_list and args[0] != 'Information':
            print(function_help[args[0]])
            sys.exit()
        elif args[0] == 'Information':
            print(Information)
            sys.exit()
        else:
            raise TypeError('Wrong function module: %s' % (args[0]))
    elif len(args) > 1:
        if args[0] == 'PCA':
            arg_val = getValueForArgument(VariantCalling_arg, args[1:])
            inputtype, inputfile, ref = arg_val['inputtype'], arg_val['inputfile'], arg_val['reference']
            outdir, name, samindex = arg_val['outdir'], arg_val['prefix'], arg_val['samindex']
            myconf = MGT.read_conf(arg_val['config'])
            threads, cleanDir, fp_TF, fqc_tf, sort_tf, markdup_tf = '4', False, False, False, False, False
            if 'threads' in arg_val.keys():
                threads = str(arg_val['threads'])
            if 'cleanDir' in arg_val.keys():
                cleanDir = True
            if 'fastp' in arg_val.keys():
                fp_TF = True
                if inputtype == 'bam':
                    print('\033[31mArgumentConflictError: Conflicting parameters: fastp, inputtype\33[0m')
                    raise ArgumentConflictError(sys.exit())
            if 'fastqc' in arg_val.keys():
                fqc_tf = True
                if inputtype == 'bam':
                    print('\033[31mArgumentConflictError: Conflicting parameters: fastqc, inputtype\33[0m')
                    raise ArgumentConflictError(sys.exit())
            if 'sort' in arg_val.keys():
                sort_tf = True
                if inputtype == 'fastq':
                    print('\033[31mArgumentConflictError: Conflicting parameters: sort, inputtype\33[0m')
                    raise ArgumentConflictError(sys.exit())
            if 'markdup' in arg_val.keys():
                markdup_tf = True
                if inputtype == 'fastq':
                    print('\033[31mArgumentConflictError: Conflicting parameters: markdup, inputtype\33[0m')
                    raise ArgumentConflictError(sys.exit())
            MGT.variantcalling(inputtype, inputfile, ref, myconf, name, samindex, outdir, threads=threads,
                               cleanDir=cleanDir, fp_TF=fp_TF, fqc_TF=fqc_tf, sort_tf=sort_tf, markdup_tf=markdup_tf)


# Customized error type
class ArgumentValueError(Exception):
    pass
class ArgumentExistError(Exception):
    pass
class ArgumentNumberError(Exception):
    pass

def getValueForArgument(function_arg, args):
    arg_val={}
    for arg in args:
        if arg.startswith('--'):
            arg = arg.strip('--')
            if (arg in function_arg.keys()) == True:
                arg_inf = function_arg[arg]
                if arg_inf[1] == 'str':
                    try:
                        val = args[args.index('--'+arg)+1]
                    except IndexError:
                        print('\033[31mArgumentValueError: No values for parameter: %s\33[0m' % (arg))
                        raise ArgumentValueError(sys.exit())
                    if val.startswith('--'):
                        print('\033[31mArgumentValueError: No values for parameter: %s\33[0m' % (arg))
                        raise ArgumentValueError(sys.exit())
                    arg_val[arg] = val
                if arg_inf[1] == 'bool':
                    arg_val[arg] = 'TF'
            elif (arg in function_arg.keys()) == False:
                print('\033[31mArgumentExistError: Parameter not exist: %s\33[0m' % (arg))
                raise ArgumentExistError(sys.exit())
    require_args = [x for x in list(function_arg.keys()) if (function_arg[x])[0] == 'require']
    require_check = False if any(True for i in require_args if not i in list(arg_val.keys())) else True
    no_arg_require = [x for x in require_args if not x in list(arg_val.keys())]
    if require_check == False:
        print('\033[31mArgumentNumberError: Missing necessary required parameter values: %s\33[0m' % (str(no_arg_require)))
        raise ArgumentNumberError(sys.exit())
    return arg_val

if __name__ == "__main__":
    main(sys.argv[1:])
